---------------------------------------------------------------------------------
Проект: Ca_03_LoggerInThreadPool_01
---------------------------------------------------------------------------------
Программа LoggerInThreadPool демонстрирует концепцию логирования внутри
пула потоков (ThreadPool) с использованием асинхронного подхода.
Особое внимание уделяется раздельной обработке задач в основном потоке сервиса (Service) и задачах,
обрабатываемых самим пулом потоков (ThreadPool).
Логирование в данном случае выполняется так, чтобы не блокировать внутренние потоки пула,
сохраняя их производительность.
________________________________________
Общая структура программы
1.	ConsoleLogger:
Реализует базовый логгер, который выводит сообщения в консоль.
Логгер поддерживает разные уровни приоритетов (например, SUCCESS, WARNING, FATAL) и временные метки.
2.	Service<loggertype>:
Класс сервиса, работающий как обертка над логгером.
Обеспечивает многопоточное логирование через очередь сообщений и поток обработки.
Он предоставляет механизм работы с логами на уровне отдельного сервиса — в одном выделенном
потоке (не пересекается с потоками основного приложения и пула потоков).
3.	ThreadPool:
Основной пул потоков для выполнения задач.
Потокобезопасная реализация предложена с использованием защитных механизмов
(мьютексов и условных переменных), а также единственного рабочего потока для обработки задач.
4.	Основной поток (main):
Программа демонстрирует параллельное взаимодействие между ThreadPool и Service,
запускает тестовые задачи и показывает примеры использования разных уровней
логирования в реалистичном сценарии.
________________________________________
Особенности программы и потоки
1.	Логирование внутри Service:
Service<loggertype> создает выделенный поток обработки (worker_thread_),
который работает только с очередью логов. Это гарантирует,
что все операции вывода логов в консоль выполняются асинхронно, без блокировки основного выполнения программы.
2.	Отделение логики ThreadPool от представления логов:
o	Логирование внутри ThreadPool организовано через вызовы методов ILogger,
	которым в данном случае является объект Service<ConsoleLogger>.
Это позволяет минимизировать влияние логирования на выполнение рабочих задач пула.
3.	Отсутствие блокировок на уровне ThreadPool:
Все задачи из очереди ThreadPool выполняются единственным потоком (sequential_thread_),
в то время как логирование выполняется другим потоком — внутри Service.
Такой подход позволяет избежать конкуренции потоков при обращении к консоли.
________________________________________
Алгоритм работы программы
1.	Создается объект ConsoleLogger — базовый механизм для логирования.
2.	На основе этого объекта инициализируется сервис Service<ConsoleLogger>,
	который берет на себя задачу управления 	потокобезопасным логированием через свою очередь.
3.	Создается объект ThreadPool, которому передается ссылка на log_service.
Внутри ThreadPool создается выделенный рабочий поток (sequential_thread_) и очередь задач.
4.	Внутри main:
o	Логируются базовые события старта программы.
o	С помощью ThreadPool добавляется предопределенная задача логирования,
	которая также наполняет логи через log_service.
o	Демонстрируются другие типы логов с разными уровнями — SUCCESS, WARNING, FATAL.
5.	После небольшой задержки работа сервиса завершается и очищается пул потоков.
________________________________________
Подробное описание классов и методов
Класс ConsoleLogger (вывод в консоль)
Этот логгер предоставляет базовый функционал вывода логов в консоль. Логгер:
•	Поддерживает чрезвычайно гибкую работу с временными метками через многоуровневый
	 формат дат/времени (например, с выводом до миллисекунд или микросекунд).
•	Работает с уровнями логов (например, SUCCESS, WARNING, FATAL, CRITICAL, DEBUG)
 	путем выделения их разными текстовыми маркерами ("[INFO]", "[ERROR]" и т.д.).
•	Использует глобальную синхронизацию через мьютекс
	(локирование вывода для устранения коллизий при записи в консоль).
Класс Service
Шаблонный класс, предназначенный для предоставления асинхронного логирования через внутреннюю очередь сообщений,
обрабатываемую в выделенном потоке.
•	Основные поля:
o	log_queue_: Очередь задач на логирование.
o	cv_, mutex_: Используются для синхронизации между потоками при доступе к очереди.
o	worker_thread_: Поток, в котором обрабатываются сообщения из log_queue_.
o	silentMode и fatalOnlyMode: Режимы фильтрации сообщений логирования.
•	Основные методы:
o	AddLogItem: Добавление сообщений в очередь. Учитываются режимы фильтрации.
o	WorkerLoop: Реализация логики обработки сообщений логирования из очереди.
o	Start/Stop: Управление запуском/остановкой сервисного потока для обработки очереди.
Класс ThreadPool
Реализует простой пул потоков с одним рабочим потоком для очереди задач. 
•	Основные поля:
o	sequential_thread_: Единственный поток для обработки задач.
o	sequential_queue_: Очередь задач для выполнения.
o	sequential_mutex_ и sequential_cv_: Синхронизация доступа к очереди задач.
•	Основные методы:
o	enqueue_sequential: Добавление задачи в очередь.
o	sequential_worker: Выполнение задач из очереди; логирование результатов выполнения.
Создание задач в ThreadPool в примере осуществляется с помощью лямбда-функций.
________________________________________
Ключевые моменты работы программы
1.	Многопоточность:
o	Логирование в Service выполняется в отдельном потоке.
o	Задачи, добавленные в ThreadPool, также выполняются в другом потоке.
Это полностью разделяет работу логгирования от выполнения задач.
2.	Безопасность потоков:
Использование очередей с мьютексами и условными переменными обеспечивает корректный многопоточный доступ без гонок.
3.	Гибкость:
Универсальная реализация Service позволяет работать не только с ConsoleLogger,
но и с любым другим логгером, который реализует интерфейс ILogger.
________________________________________
Рекомендации по улучшению (код ревью)
1.	Обработка исключений для времени:
	Метод formatDateTime делает вызов localtime_s, который может выбрасывать исключения.
	Вместо runtime_error можно рассмотреть использование более точного исключения
	(например, пользовательского класса).
2.	Прерывание потоков:
	В ThreadPool и Service потоковые функции (например, WorkerLoop)
	используют наличие очередей для завершения,
	однако стоит добавить дополнительную проверку или логику быстрого завершения
	 для большего контроля.
3.	Единообразие обработки исключений:
	Там, где мы используем try-catch, стоит привести единый формат обработки ошибок.
	Например, в ThreadPool обработка ошибок каждого задания из очереди выполняется,
	но соответствующий LogLevel используется только с FATAL.
	Можно добавить хотя бы информационное логирование ошибок с деталями
	(DEBUG при восстановлении).
4.	Оптимизация конструктора ThreadPool:
	Конструктор, принимающий Service<ConsoleLogger>, перегружает аналогичный функционал,
	что приводит к минимальным изменениям;
	стоит объединить логику и уменьшить дублирование кода.
________________________________________
Заключение
Программа LoggerInThreadPool является отличной демонстрацией взаимодействия
нескольких потоков для раздельной обработки задач и логирования.
Выделение логирования в виде сервиса (с использованием очереди) и применение пула потоков
для выполнения рабочих задач делают архитектуру программы гибкой, модульной и масштабируемой.
Несмотря на небольшие области для доработки, текущая реализация хорошо справляется
с поставленной задачей управления многопоточным логированием.