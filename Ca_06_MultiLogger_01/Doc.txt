-------------------------------------------------------
Проект Ca_06_MultiLogger_01
------------------------------------------------------
Подробное описание проекта и код ревью
Проект представляет собой модульную систему логирования,
основанную на концепции множественных логгеров с различной функциональностью.
Логгеры централизованно управляются через класс Logger,
предоставляющий единый интерфейс для логирования и настройки нескольких типов логгеров.
Основные элементы системы: 
1.	Форматирование времени и даты:
Осуществляется через DateTimeFormatter.hpp/.cpp.
Это универсальный механизм для задания временных меток с гибкими форматами.
2.	Интерфейс логгера (ILogger):
Определяет абстрактный контракт для всех логгеров,
обеспечивая модульность и возможность добавлять новые виды логгеров в будущем.
3.	Три типа логгеров:
o	ConsoleLogger: Печатает логи в консоль с возможностью настройки формата и включения/отключения логов.
o	MemoryLogger: Сохраняет логи в оперативной памяти с ограничением на количество записей.
o	FileLogger: Сохраняет логи в файл, поддерживает создание и чтение логов из файла.
4.	Центральный менеджер логирования (Logger):
Управляет всеми добавленными логгерами, распределяет сообщения между ними и заботится о простоте их вызова.
________________________________________
Ключевые моменты структуры
•	Код использует принципы ООП:
o	Полиморфизм через интерфейс ILogger.
o	Инкапсуляция: каждый логгер отвечает за внутреннее устройство сам.
o	Легкость расширения: если потребуется создать новый логгер (например, NetworkLogger), это будет легко.
•	Используются современные библиотеки стандартной библиотеки C++:
o	<chrono> для работы с временными метками.
o	<iomanip> для форматирования.
o	<iostream> и <fstream> для работы с вводом-выводом.
________________________________________
Подробный анализ кода
1. DateTimeFormatter.hpp/.cpp
Одной из основ системы стало форматирование временных меток.
Базовые моменты:
•	Реализован удобный способ форматирования дат через перечисление DateTimeFormat.
•	Используются современные функции (std::put_time),
	а также безопасная версия localtime_s для потокобезопасности.
•	Поддерживаются миллисекунды и микросекунды.
Замечания:
•	Код использует ручную обработку ошибок (errno_t), что хорошо,
	но может быть сложным для дальнейшего сопровождения.
•	Чрезмерно привязано к форматированию времени текущего момента.
	Форматирование пользовательских временных точек (например, заданного времени) не поддерживается.
2. Логика интерфейса ILogger
Класс ILogger является интерфейсом, который задает следующий функционал:
•	Основные методы:
o	enable(bool status): активация и деактивация логгера.
o	log(const LogItem& item): запись сообщения.
o	print() const: вывод на экран.
o	set_dt_format(DateTimeFormat format): выбор формата времени.
•	Использует виртуальные деструкторы, что правильно для полиморфных классов.
Замечания:
•	Логика метода print() недостаточно детализирована. В некоторых случаях, например,
	в консольных логгерах, не совсем очевидно, какой именно результат должен быть выведен.
3. ConsoleLogger
Класс полностью реализует интерфейс, выполняя вывод сообщений прямо в консоль.
Плюсы:
•	Настройка формата временных меток — гибко и удобно. Поток вывода определяется через std::cout.
Замечания:
•	Класс печатает только текущие сообщения, он не сохраняет историю сообщений.
	Если потребуется повторный вывод, этого сделать нельзя.
4. MemoryLogger
Эффективно сохраняет логи в вектор в памяти:
•	set_max_logitems(): позволяет ограничить размер истории.
•	При переполнении удаляет самые старые записи.
Плюсы:
•	Отличный вариант для кэша логов в оперативной памяти.
•	Реализация метода print() позволяет удобно вывести все сохраненные записи.
Замечания:
•	Удаление первых элементов (из-за logs.erase(logs.begin())) неэффективно при большом объеме данных.
	Можно заменить на кольцевой буфер или очередь с фиксированным размером.
5. FileLogger
Сохраняет логи в файл:
•	Включает механизмы открытия и закрытия файлов.
•	Имеет гибкость при выводе записей из файла.
Плюсы:
•	Простая и понятная организация через std::ofstream и std::ifstream.
Замечания:
•	Работает с файлом в режиме "добавления". При необходимости обновления старых записей потребуется переписывать реализацию.
•	Метод print() выводит только содержимое файла,
	но не предоставляет возможность ограничить количество читаемых записей.
6. Класс Logger (Менеджер)
Служит центральным связующим звеном для всех логгеров:
•	Поддерживает регистрацию нескольких объектов ILogger.
•	Каждое сообщение (LogItem) отправляется всем зарегистрированным активным логгерам.
Плюсы:
•	Удобство взаимодействия с множеством логгеров.
•	Гибкость: можно подключать/отключать логгеры на лету.
Замечания:
•	Формат временных меток и другие настройки применяются индивидуально для каждого логгера.
	Нет единого централизованного управления настройками, что может усложнить их синхронизацию.
________________________________________
Возможные улучшения и рекомендации
1.	Оптимизация MemoryLogger:
Устранить проблему с logs.erase(logs.begin()), заменив её на циклический буфер, стек или очередь фиксированного размера.
2.	Расширение DateTimeFormatter:
Добавить возможность форматирования пользовательских временных точек, а не только текущего момента времени.
Это сделает formatDateTime более универсальным.
3.	Обработка ошибок в FileLogger:
Если файл закрыт или запись вызвала ошибку, нужно логировать такие события 
в консоль или автоматически отключать логгер.
4.	Централизованное управление настройками:
Сделать так, чтобы изменения формата времени в Logger автоматически применялись
ко всем зарегистрированным логгерам.
5.	Тестирование многопоточности:
Проверить корректность работы системы в многопоточной среде.
Для этого можно использовать std::mutex везде, где требуется защита общих данных.
6.	Методы для фильтрации логов:
Добавить возможность фильтрации сообщений по уровню (например, логирование только WARNING и FATAL)
или временным интервалам.
________________________________________
Подробности работы программы (main)
Цель программы: протестировать три активных логгера — консольный, память, файл — в условиях одновременной работы.
•	ConsoleLogger сразу выводит сообщения в std::cout.
•	MemoryLogger ограничивает количество сохраненных сообщений (100 по умолчанию).
•	FileLogger сохраняет все сообщения в файл FileLogger.txt.
Все события проходят через один менеджер (Logger),
который обеспечивает широкую модульность и возможность простого повторного использования кода.
Пример работы:
1.	Логирование двух сообщений:
   [SUCCESS] Hello world
   [WARNING] Good bye
Сообщения передаются всем активным логгерам одновременно.
1.	Вывод сообщений:
o	ConsoleLogger: сообщения уже напечатаны.
o	MemoryLogger: выводит последние 100 сообщений.
o	FileLogger: читает содержимое файла и выводит все записи.
________________________________________
Заключение
Проект является примером качественного подхода к модульности и соблюдению принципов SOLID.
Код позволяет легко расширять функциональные возможности логгеров и масштабировать саму систему.
С небольшими доработками (например, оптимизация MemoryLogger и централизованное управление настройками формата),
он может стать основой для любого высоконагруженного приложения.
