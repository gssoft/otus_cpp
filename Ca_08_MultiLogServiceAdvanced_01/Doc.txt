Подробное описание программы
Основное назначение

Данная программа представляет собой мощную систему логирования,
созданную с использованием принципов шаблонного программирования,
многопоточности и модульной структуры.
Система предоставляет гибкий подход к обработке логов, позволяя подключать разные типы логгеров,
такие как консольный (ConsoleLogger), файловый (FileLogger), и логгер на основе памяти (MemoryLogger).
Ключевая особенность заключается в использовании канально-последовательного многопоточного исполнителя
(MultiSequentialExecutor), что позволяет обрабатывать логирование для каждого логгера на его собственном
канале и сохранять порядок записи.

Разделение на модули делает систему очень гибкой и легко модифицируемой, например, можно добавить новые типы логгеров, таких как HttpLogger или GrpcLogger, или заменить реализацию исполнителя (executor), чтобы адаптироваться под требования производительности.
Архитектура проекта

    Форматирование времени: DateTimeFormatter
        Предоставляет удобные способы получения текущего времени в различных форматах,
        включая миллисекунды и микросекунды.
        Использует безопасные функции работы с временем, такие как localtime_s,
        для предотвращения возможных ошибок в многопоточной среде.
    Система логирования:
        ILogger (абстрактный интерфейс логгеров):
            Логгер работает через общий интерфейс, это позволяет легко добавлять новые реализации логгеров.
            Поддерживает базовые методы, необходимые логгеру: включение/выключение, логирование сообщения,
            печать логов, установка формата времени.
        Реализации логгеров (в RealLoggers.hpp):
            ConsoleLogger: логирует напрямую в консоль.
            MemoryLogger: хранит логи в памяти, с максимальным ограничением.
            FileLogger: сохраняет логи в текстовый файл с возможностью выбора имени файла.
        Центральный класс логирования: MultiLogger
            Управляет несколькими логгерами.
            Поддерживает ID каналов для маршрутизации логов между логгерами.
            Автоматически вызывает метод log каждого подключенного логгера, если он включен.
    Многопоточность и выполнение задач:
        SingleThreadExecutor:
            Простой однопоточный исполнитель задач.
            Используется в базовом шаблоне MultiLogService.
        MultiSequentialExecutor:
            Ключевая часть системы: обеспечивает многоканальную последовательную обработку задач.
            Каждому каналу (логгеру) назначается своя очередь задач,
            но обрабатываются они в последовательности в рамках потока.
            Устраняет риск блокировки медленных логгеров (например, файлового) быстрыми.
        IExecutor (абстрактный интерфейс исполнителя):
            Позволяет заменить исполнителя на другую реализацию без изменения основного кода.
    Объединение логики логгера и исполнителя:
        MultiLogService и MultiLogServiceAdvanced:
            Генерические (шаблонные) классы, объединяющие MultiLogger и конкретный тип исполнителя 
            (SingleThreadExecutor или MultiSequentialExecutor).
            Разделяет задачи логирования между исполнителем и логгером, позволяя обработке задач
            происходить асинхронно и эффективно.

Подробный Code Review
1. DateTimeFormatter.hpp

    Плюсы:
        Перечисление DateTimeFormat позволяет гибко выбирать формат времени.
        Заголовочный файл корректно использует include guard и #pragma once.
        Поддерживает миллисекунды и микросекунды.
    Минусы и замечания:
        Следует добавить документацию к функции formatDateTime, чтобы объяснить, какие форматы она поддерживает.
        Передача DateTimeFormat по ссылке const & здесь излишня, так как это перечисление, передача по значению будет эффективнее.

2. DateTimeFormatter.cpp

    Плюсы:
        Использует функции из <chrono> для работы с микросекундами/milliseconds.
        Потокобезопасность обеспечивается с помощью std::lock_guard<std::mutex>.
        Безопасно обрабатывает преобразование времени через localtime_s.
    Минусы и замечания:
        Общий std::mutex _mutex может стать узким местом, если formatDateTime вызывается из разных потоков.
        Лучше сделать его локальным то есть определять прямо в функции.
        Обработка ошибок выполнения localtime_s прописана корректно, но имеет избыточные комментарии.
        Тестовый блок обработки исключений (закомментированный try-catch) стоит удалить или раскомментировать с реальной логикой.
        Лишнее дублирование логики в case операторе.
        Например, std::put_time(&local_tm, "%y.%m.%d %H:%M:%S") встречается в нескольких местах.
        Можно вынести общую часть в отдельный метод.

3. MultiLogger.hpp

    Плюсы:
        Определение структуры LogItem для описания лог-сообщений делает код читаемым и расширяемым.
        Реализация ILogger как интерфейса позволяет подключать множество логгеров с общей базовой функциональностью.
        Система каналов логгера упрощает маршрутизацию логов.
        Основной класс MultiLogger эффективно управляет группой логгеров.
    Минусы и замечания:
        Перечисление MessageStatus лучше дополнить методами для преобразования в строку (вместо использования ? в toString).
        Метод char timeBuffer в log использует ctime_s, который несовместим с POSIX.
        Если поддержка POSIX не приоритетна, это нормально, иначе нужно использовать стандартные альтернативы.
        ID каналов логгеров в setup_channel_id не должны быть "захардкожены".
        Возможно, стоит добавить динамическую регистрацию каналов.

4. MultiSequentialExecutor.hpp

    Плюсы:
        Совершенное решение для асинхронного выполнения задач в многоканальной среде.
        Использование логики проверки реального количества "зависших" задач.
        Поддержка контроля активности потоков через activeThreads.
    Минусы и замечания:
        В методе execute, если передан несуществующий ID канала,
        поведение остаётся неопределённым (не создаётся новый канал).
        Может быть добавлен throw или гарантия добавления канала при необходимости.
        Метод getTaskQueueSize вычисляет длину всех очередей с блокировкой,
        что может повлиять на производительность в масштабных системах.

5. RealLoggers.hpp

    Плюсы:
        Отлично организована триада ConsoleLogger, MemoryLogger и FileLogger, каждая из которых имеет чёткое назначение.
        Использование std::mutex делает работу потокобезопасной.
        Методы включения/выключения логгеров (enable) хорошо интегрированы.
    Минусы и замечания:
        В MemoryLogger при достижении максимального размера логов (maxLogItems) вызывается метод erase.
        Однако лучше реализовать циклический буфер для повышения производительности при большом количестве логов.
        У FileLogger метод set_file_name не проверяет, открыт ли файл.
        Это может привести к некорректному состоянию (например, попытке открыть файл под другим именем,
        когда предыдущий уже открыт).

6. MultiLogServiceAdvanced.hpp

    Плюсы:
        Шаблонный класс обеспечивает модульность в выборе типов логгеров и исполнителей.
        Поддерживает каналы выполнения, повышая производительность.
    Минусы и замечания:
        Следует реализовать обработку ошибок на уровне executor.execute, чтобы исключить ситуации,
        когда задача не выполняется из-за ошибочного состояния.

7. main()

    Плюсы:
        Демонстрирует основные возможности системы (подключение логгеров, логирование в разные каналы, вывод).
        Хорошо структурирован, шаги выполнены последовательно.
    Минусы и замечания:
        В заключительном блоке std::cout закомментированный вывод состояния исполнения можно реализовать корректно.
        Это бы улучшило итоговую демонстрацию работы программы.
        Для FileLogger после завершения логирования необходимо выполнить close_file вручную,
        чтобы гарантировать корректную запись в файл.

Заключение

Программа успешно реализует систему многоканального логирования
на базе модульной программы с многопоточной обработкой.
Однако есть несколько важных доработок:

    Улучшить проверку ошибок и исключений (например, для каналов исполнителя).
    Провести оптимизацию работы с памятью в MemoryLogger.
    Развить обработку ID каналов для более автоматизированной маршрутизации.
