// Ca_XX - "Это первые буквы в Названиях Проектов в Solution VisualStudio".
// Эволюция программного кода для Logger
//
// Во многих проектах тоже есть краткое описание, что они делапют.

Ca_01.

/ В начале было слово ...
// А у нас в начале был ConsoleLogger
// совсем простой как в этом проекте.
// Он логирует разные сообщения.
// В main() все написано.

ConsoleLogger logger;

Ca_02.
// Реализация ConsoleLogger
// ConsoleLogger работает в контексте Service с одним потоком выполнения

ConsoleLogger console_logger;
Service<ConsoleLogger> console_log_service(std::move(console_logger));

Ca_03.
// ConsoleLogger
// Service c одним thread (поток исполнения) параметризирован ConsoleLogger
// Получаетcя ConsoleLogger работающий с предоставленным одним Thread от Service
// Демонстрируется работа log_service
//  - в контексте основной программы main()
//  - в контексте THreadPool - логировать используя только свой поток и не использовать внутренние потоки ThreadPool
// 

ConsoleLogger consoleLogger;
Service<ConsoleLogger> log_service(std::move(consoleLogger));
ThreadPool threadPool(log_service);

Ca_04.
// Реализация SingleExecutor - Исполнитель с одним потоком
// Реализация ConsoleLogger - Логер для регистрации сообщений в Консоли

// Разделим Поведение (ConsoleLogger) и Исполнение (SingleExecutor)
ConsoleLogger logger;  // Реализация логгера
SingleExecutor executor(logger);  // Однопоточный исполнитель (Executor)

Ca_05.
// В начале делаем четкое разделение отвественности двух компонентов и далее
// Объединяем Logger(Поведение) и Executor(Исполнение) в один Wrapper с именем LogService
// через ШАБЛОННУЮ МАГИЮ
// Теперь легко и непринужденно можно менять и Поведение и Исполнение
// при помощи других разработанных классов.

LogService<ConsoleLogger, SingleThreadExecutor> log_sevice;

Ca_06.
// Создаем основной менеджер логов
Logger logger; // MultiLogger c ConsoleLogger, MemoryLogger, FileLogger
Logger - менеджер логеров
- ConsoleLogger
- MemoryLogger
- FileLogger
В следующем проекте переименуем этот Logger в MultiLogger

Ca_07.
 // Создаем MultiLogService, связывая MultiLogger и SingleThreadExecutor в Wrapper c именем MultiLogService

MultiLogService<MultiLogger, SingleThreadExecutor> multi_log_service;

Ca_08.
MultiLogServiceAdvanced<MultiLogger, MultiSequentialExecutor> multi_log_service_adv(3); // Красота.
Этот проект не взлетел.
Он работает но, не так как надо. Я туда ошибочно не тот ThreadPool вставил.
Оставляю на память, потому что с точки зрения шаблонного кода это одна из лучших шаблонных реализаций.
Все понятно что где какой компонент и что он делает.
Можно разрабатывать все компоненты отдельно.

Ca_09.
Реализация MultiLogger (Поведение) в однопоточном потоке (Исполнения) SingleExecutor
// Создаем SingleExecutor
SingleExecutor executor;
// Создаем MultiLogger, параметризованный SingleExecutor
MultiLogger<SingleExecutor> multiLogger(executor);

MultiLogger<SingleExecutor> multiLogger(executor);
Скромненько.

Ca_10.
Реализация MultiLogger (Поведение) в многопоточном потоке (Исполнения) MultiSequentialExecutor

    // Создаем MultiSequentialExecutor с 3 SingleExecutor
    MultiSequentialExecutor<SingleExecutor> executor(3);

    // Создаем MultiLogger, используя MultiSequentialExecutor
    MultiLogger<MultiSequentialExecutor<SingleExecutor>> multiLogger(executor);
Пошла жара.

Ca_11.
MultiLoggerMultiThreaded<MultiLogger<MultiSequentialExecutor<SingleExecutor>>, // MultiLogger
     MultiSequentialExecutor<SingleExecutor>> // MultiSequentialExecutor
     multiLogger_multiThreaded_service(3);

Если кто сразу не понял, это ОДНА строка кода. Шаблонная магия рулит.
Вот это совсем уже трэш. Сделан Wrapper MultiLoggerMultiThreaded.
Все компоненты понятны. Максимальная гибкость. Любую конструкцию можно обновлять отдельно от остальных.
Там описание в проекте есть в main().

Здесь представлена Эволюция программного кода Регистратора сообщений.
Мы начали с ConsoleLogger logger в проекте CA_01:
то есть c std::cout << "Hello World" << std::endl;

и закончили вот таким монстром в проекте CA_11:
MultiLoggerMultiThreaded<MultiLogger<MultiSequentialExecutor<SingleExecutor>>, // MultiLogger
     MultiSequentialExecutor<SingleExecutor>> // MultiSequentialExecutor
     multiLogger_multiThreaded_service(3);
Максимальная гибкость и взаимозаменямость всех компонентов.

Всего хорошего до новых встреч в эфире.
