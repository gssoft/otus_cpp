------------------------------------------------------------------
Проект Ca_04_SingleExecutor_01
------------------------------------------------------------------
Представляет собой простой пример многопоточного логирования с четким разделением на две концепции:
•	Поведение (Behavior): Реализовано через логгер ConsoleLogger,
	который отвечает за обработку логов и форматирование сообщений.
•	Исполнение (Execution): Реализовано через SingleExecutor,
	который берет на себя управление выполнением задач
	(в данном случае логированием) в однопоточном исполнителе.
Ключевая идея программы — разделение обязанностей:
1.	ConsoleLogger отвечает только за форматирование логов,
	их вывод в консоль и потокобезопасность самого процесса вывода.
2.	SingleExecutor управляет выполнением задач (логирования) в отдельном выделенном потоке.
	Логирование происходит асинхронно по мере поступления задач в очередь.
________________________________________
Задачи программы
1.	Обработка логов:
	Программа принимает логи разных уровней (SUCCESS, INFO, WARNING, FATAL, и т.д.)
 	и передает их на исполнение через SingleExecutor.
2.	Многопоточность:
	Логирование организовано в отдельном потоке (используя std::jthread),
	что позволяет основному потоку программы продолжать работу независимо от выполнения логов.
3.	Потокобезопасность:
	Очередь задач защищена мьютексами,
	а для синхронизации потоков используется std::condition_variable.
________________________________________
Ключевые компоненты
1. BaseLogger.hpp
Определяет интерфейс базового логгера. Это позволяет в будущем заменить ConsoleLogger
на другой тип логгера (например, запись в файл, удаленный сервер и т.д.),
не изменяя реализации SingleExecutor. 
•Ключевой метод: — виртуальная функция, которая будет реализована в наследниках.
2.ConsoleLogger.hpp / ConsoleLogger.cpp
ConsoleLogger — это реализация BaseLogger, которая выводит лог-сообщения в консоль. 
•	Основные моменты:
o	Форматирует лог-сообщения с учетом уровня логирования (FormatLogLevel).
o	Добавляет временные метки к сообщениям.
o	Гарантирует потокобезопасный вывод в консоль с использованием std::mutex.
Пример форматированного вывода:
[12:34:56] [INFO] This is an informational message.
3. SingleExecutor.hpp / SingleExecutor.cpp
SingleExecutor — универсальный исполнитель, который управляет выполнением задач (в данном случае, логов)
в одном потоке. Он реализует следующие ключевые функции:
•	Очередь задач:
o	Используется std::queue, которая хранит пары уровня логирования и сообщения.
o	Доступ к очереди потокобезопасен через мьютекс.
•	Обработка задач в отдельном потоке:
o	Используется std::jthread для запуска обработчика задач (WorkerLoop()).
o	Поток завершает работу, когда объект уничтожается или вызывается метод Stop().
•	Синхронизация потоков:
o	Для ожидания задач используется std::condition_variable.
4. main()
Входная точка программы:
•	Создается логгер (ConsoleLogger) и исполнитель (SingleExecutor).
•	Логи передаются через SingleExecutor, который обрабатывает их асинхронно в своем потоке.
•	На завершающем этапе выполнения поток с задачами корректно останавливается.
________________________________________
Особенности реализации
Использование std::jthread
В C++20 введен новый тип std::jthread, который упрощает управление потоками,
автоматически завершая их (join) при выходе из области видимости.
Это значительно улучшает безопасность многопоточных программ.
Здесь std::jthread используется для реализации рабочего потока WorkerLoop().
Асинхронное исполнение задач
Благодаря особенностям SingleExecutor логи обрабатываются асинхронно.
Основной поток (main) добавляет задачи в очередь через метод Log(),
а рабочий поток постепенно извлекает их и передает на обработку логгеру.
Потокобезопасность
Для одновременного безопасного доступа к разделяемым ресурсам (очередь logQueue_) используется std::mutex.
Синхронизация между потоками осуществляется с помощью std::condition_variable,
что предотвращает активное ожидание (busy waiting) и экономит ресурсы.
________________________________________
Обзор кода (код ревью)
1. BaseLogger.hpp
•	Хорошо:
o	Интерфейсный класс задает четкую структуру. Это облегчает замену реализации логгера.
o	Используется enum class для логических групп уровней логирования — это надежнее, чем обычные enum.
•	Что можно доработать:
o	Добавить документацию методов, чтобы было ясно, как ожидается использование интерфейса.
2. ConsoleLogger.hpp / ConsoleLogger.cpp
•	Хорошо:
o	Форматирование временной метки сделано аккуратно с использованием <ctime> и <chrono>.
o	Метод FormatLogLevel реализован корректно, покрывает все уровни логирования.
o	std::mutex защищает std::cout, что необходимо для потокобезопасного вывода.
•	Что можно улучшить:
o	В FormatLogLevel можно добавить обработку значения по умолчанию (default).
o	Текущий подход с мьютексом работает,
	но может замедлить производительность при большом количестве одновременно исполняемых потоков.
	Рассмотреть возможность использования буферизированной очереди.
3. SingleExecutor.hpp / SingleExecutor.cpp
•	Хорошо:
o	Полностью изолирует исполнение задач в своем потоке.
o	Использует современные механизмы C++20 (std::jthread и std::atomic_bool).
o	Поток завершается корректно при вызове Stop(), даже если очередь пуста.
o	Четко разделяет выполнение (очередь, поток) и поведение (логер).
o	Избавлен от гонки данных благодаря мьютексу.
•	Что можно улучшить:
o	В методе Stop() можно явно очищать очередь задач.
o	Добавить функционал максимальной длины очереди, чтобы избежать потенциального переполнения памяти.
o	Возможно, стоит использовать std::deque вместо std::queue,
	чтобы иметь больше гибкости в управлении задачами.
4. main()
•	Хорошо:
o	Демонстрирует базовый сценарий работы (создание, добавление логов, завершение).
o	Имитирует реальную рабочую нагрузку с помощью std::this_thread::sleep_for.
•	Что можно улучшить:
o	Добавить больше сообщений разного уровня для демонстрации.
o	Рассмотреть обработку исключений на случай непредвиденных ошибок.
________________________________________
Вывод
Программа выполнена качественно и демонстрирует правильное применение современных возможностей языка C++ (C++20).
Реализованное разделение на Поведение (ConsoleLogger) и Исполнение (SingleExecutor)
делает код переиспользуемым и легко расширяемым. 
Для дальнейших улучшений можно:
1.	Добавить дополнительные сценарии работы (например, создание нескольких экземпляров логгера).
2.	Реализовать максимальную длину очереди для предотвращения перегрузки памяти.
3.	Расширить функционал логгера (например, писать логи не только в консоль, но и в файл).
Код читаемый, поддерживаемый и легко расширяемый,
что делает его отличным примером промышленного кода для задач логирования.