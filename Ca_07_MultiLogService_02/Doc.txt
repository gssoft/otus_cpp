-------------------------------------------------------------
Проект Ca_07_MultiLogService_02
-------------------------------------------------------------
MultiLogService<MultiLogger, SingleThreadExecutor> multi_log_service;
Подробное описание программы
Программа представляет собой мощную реализацию системы логирования,
которая демонстрирует использование принципов шаблонного программирования (template magic),
объектно-ориентированного подхода и многопоточности.
Основная концепция заключается в создании универсальной инфраструктуры для логирования,
которая обеспечивает поддержку различных типов логгеров (консоль, память, файл),
управляет их взаимодействием через мульти-логгер, а также передает задачи через шаблонный сервис,
использующий executor (исполнитель задач).
Этот сервис (MultiLogService) представляет собой связующее звено между логированием
и асинхронным выполнением задач, обеспечивая высокую гибкость и масштабируемость системы.
________________________________________
Основные элементы программы
1. DateTimeFormatter
DateTimeFormatter предоставляет удобный способ работы с форматированием времени. 
Ключевые особенности:
•	Перечисление DateTimeFormat описывает несколько популярных форматов отображения времени:
	с/без даты, с миллисекундами/микросекундами и их комбинации.
•	Функция formatDateTime использует библиотеку <chrono> и умеет обрабатывать время вплоть
	до уровня микросекунд.
•	Поддерживается локальное форматирование времени с использованием безопасной функции localtime_s.
Этот модуль расширяемый, легко настраиваемый и может использоваться для всех логгеров,
задавая единый формат временных меток.
________________________________________
2. ILogger: Базовый интерфейс для логгеров
Базовый класс ILogger определяет универсальный интерфейс для всех типов логгеров.
Он гарантирует соблюдение единого контракта для всех дочерних классов, что упрощает их интеграцию и управление. 
Методы интерфейса:
•	enable(bool status) — включает или отключает логгер.
•	log(const LogItem& item) — осуществляет процесс логирования сообщения.
•	print() — вывод хранимых логов (актуально для памяти/файлов, но избыточно для консоли).
•	set_dt_format(DateTimeFormat format) — настройка формата времени для конкретного логгера.
•	isEnabled() — проверяет активность логгера.
________________________________________
3. LogItem и MessageStatus
LogItem описывает структуру одного лог-сообщения:
•	id — уникальный идентификатор (генерируется логгером при создании сообщения).
•	time — время в строковом формате.
•	status — статус сообщения (SUCCESS, WARNING, FATAL).
•	description — описание события.
Метод toString формирует человеко-читаемую строку, которая легко интерпретируется пользователем.
MessageStatus — перечисление уровня важности сообщения, что позволяет задавать правила фильтрации
или форматирования логов.
________________________________________
4. MultiLogger
MultiLogger — это многокомпонентный класс-менеджер, который агрегирует несколько логгеров (ILogger)
и управляет процессом логирования одновременно для всех добавленных логгеров. 
Ключевые функциональности:
•	Добавление логгеров: Метод addLogger позволяет динамически расширять список активных логгеров.
•	Логирование сообщений: Метод log создает лог-сообщение и отправляет его всем подключенным логгерам,
одновременно проверяя их активность (isEnabled).
•	Вывод логов: Метод printAll вызывает метод print каждого подключенного логгера, выводя их содержимое.
Этот класс централизует управление логами и обеспечивает согласованность между различными логгерами.
________________________________________
5. RealLoggers: Конкретные реализации логгеров
В системе реализованы три вида логгеров:
a) ConsoleLogger
Этот логгер выводит сообщения в консоль.
Особенности:
•	Использует текущий формат времени (set_dt_format).
•	В реальном времени печатает все логи (std::cout).
•	Минимальные накладные расходы,
	но отсутствие сохранения истории сообщений делает его не подходящим для долгосрочного анализа.
b) MemoryLogger
Сохраняет логи в оперативной памяти в виде массива сообщений (std::vector<LogItem>).
Особенности:
•	Поддерживает механизм ограничений на максимальное число сохраняемых логов (set_max_logitems).
•	Интуитивный интерфейс просмотра через print.
•	Подходит для временного хранения логов в ограниченном объеме.
c) FileLogger
Сохраняет логи в файл, поддерживает постоянное хранение данных.
Особенности:
•	Файл открывается в режиме добавления (std::ios::app), что позволяет сохранять старые записи.
•	Реализует методы настройки имени файла (set_file_name)
	и безопасного открытия/закрытия файла (open_file, close_file).
•	Логи можно просматривать как через файл, так и через метод print.
________________________________________
6. SingleThreadExecutor
SingleThreadExecutor — это простая реализация исполнителя задач.
Особенности:
•	Использует механизм очередей (std::queue) и блокировку потоков 
	(std::mutex, std::condition_variable) для управления задачами.
•	Работает в отдельном потоке.
•	Выполняет задачи последовательно, исключая гонки потоков — это оптимально для большинства задач логирования.
Этот класс позволяет асинхронно записывать логи, освобождая основной поток программы.
________________________________________
7. MultiLogService
MultiLogService — это шаблонный класс, который связывает MultiLogger и IExecutor.
Шаблонный параметр:
•	LoggerType: может быть любой реализацией мульти-логгера (здесь — MultiLogger).
•	ExecutorType: может быть любой конкретной реализацией экспортера задач (здесь — SingleThreadExecutor).
Особенности:
•	Реализует асинхронное логирование.
•	Инкапсулирует всю сложность работы с многопоточностью.
•	Предоставляет единый API для добавления логгеров (addLogger),
	записи логов (log) и просмотра всех сохраненных данных (printAll).
Шаблонность позволяет легко заменить многопоточный исполнитель или другой логгер,
делая класс универсальным, расширяемым и повторно используемым в любых приложениях.
Основной код (main())
В функции main демонстрируется вся мощь и простота использования системы:
1.	Создается объект MultiLogService, связывающий MultiLogger с SingleThreadExecutor.
2.	Добавляются три типа логгеров: ConsoleLogger, MemoryLogger и FileLogger.
3.	Логи записываются с использованием метода log (уровень сообщения и содержание передаются как параметры).
4.	Используется printAll для вывода всех логов из активных логгеров.
Пример показал следующие взаимодействия:
•	Асинхронный сбор логов.
•	Прямая настройка времени, объемов данных и файловых путей.
•	Универсальный механизм вывода логов.
________________________________________
Код ревью
1.	Положительные моменты:
o	Логгеры полностью изолированы — можно удалить или модифицировать один из них,
	не затрагивая остальные модули.
o	Используется шаблонное программирование, что позволяет быстро внедрить
	новые типы исполнителей задач или логгеров.
o	Код хорошо структурирован, читаем, легко поддерживается.
o	Реализованы методы безопасной работы с памятью, потоками и файлами.
o	Методы управления временем (DateTimeFormatter) гибки и эффективны.
2.	Замечания и возможные улучшения:
o	Отсутствие тестов: Очень важно писать unit-тесты для такой сложной системы, чтобы исключить регрессии.
o	Логирование исключений: Например, в случае ошибки при записи файла (закрытый файл) логгер просто отчитает ошибку.
	Было бы полезно логировать подобные события в консоль через stderr или отдельный лог.
o	Использование умных указателей: Везде применяются std::shared_ptr, но для некоторых логгеров достаточно std::unique_ptr.
o	Гибкость управления потоками: На данный момент используется только SingleThreadExecutor.
	Хорошо бы предусмотреть многопоточный вариант для больших нагрузок.
Заключение
Эта программа является эталоном модульного и шаблонного программирования.
Она использует ряд архитектурных паттернов, таких как "Стратегия" для логгеров и "Исполнитель задач" для потоков,
что делает ее гибкой, расширяемой и оптимальной для использования в различных проектах.
