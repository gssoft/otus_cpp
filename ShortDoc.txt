Название Проектной работы:
"Эволюция программного кода для регистрации сообщений".

Аннотация к проектам
---------------------------------
1. Ca_01_ConsoleLogger_01 – проект
----------------------------------
Реализация примитивного ConsoleLogger
ConsoleLogger — это инструмент для логгирования, который предоставляет
средства для записи сообщений в консоль с различными уровнями важности и временными метками.
Его основная задача заключается в облегчении процесса отладки и документирования выполнения программы.
Это отдельный, минималистический модуль, который отличается простотой использования и гибкостью настройки.
----------------------------------
2. Ca_02_LoggerService_01
------------------------- --------
Реализация ConsoleLogger + Service (Исполнение)
ConsoleLogger работает в контексте Service с одним потоком выполнения.
Service<ConsoleLogger> — это программа, которая дополняет функционал
ConsoleLogger функциональностью сервиса.
Основная задача этой программы — демонстрация взаимодействия
ConsoleLogger (поведение) с компонентом Service(Исполнение).
Service представляет собой функциональную единицу, которая предоставляет поток выполнения
для ConsoleLogger, который выполняет логирование.
--------------------------------------
3. Проект: Ca_03_LoggerInThreadPool_01
--------------------------------------
Программа LoggerInThreadPool использует компонент Service<ConsoleLogger> из предыдущнго проекта. 
Демонстрируется работа log_service
 - в контексте основной программы main()
 - в контексте THreadPool - логировать используя только свой поток 
и не использовать внутренние потоки ThreadPool
------------------------------------------------------------------
4. Проект Ca_04_SingleExecutor_01
------------------------------------------------------------------
В этом проекте появляется SingleExecutor 
и еще боллее четко сделано разделение на
Поведение (ConsoleLogger) и Исполнение (SingleExecutor) 
Реализация SingleExecutor - Исполнитель с одним потоком
Реализация ConsoleLogger - Логер для регистрации сообщений в Консоли
Код пока еще обычный без шаблонов.
ConsoleLogger logger;  // Реализация логгера
SingleExecutor executor(logger);  // Однопоточный исполнитель (Executor)
----------------------------------------------------------------------
Проект Ca_05_Logger_Executor_In_Service_01
----------------------------------------------------------------------
В этом проекте применяется "шаблонная магия"
ConsoleLogger(Поведение) и SingleThreadExecutor(Исполнение) объединяются в
Wrapper c именем LogService.
Было так:
SingleExecutor executor(logger);
Стало вот так:
LogService<ConsoleLogger, SingleThreadExecutor> log_service;
Теперь легко и непринужденно можно менять и Поведение и Исполнение
при помощи других разработанных классов.
-------------------------------------------------------
Проект Ca_06_MultiLogger_01
------------------------------------------------------
Пришло время усилить Logger.
В этом проекте мы значительно усиливаем фукциональность Logger.
Был ConsoleLogger Стал Logger c разными типами Логеров:
ConsoleLogger: Печатает логи в консоль с возможностью настройки формата и включения/отключения логов.
MemoryLogger: Сохраняет логи в оперативной памяти с ограничением на количество записей.
FileLogger: Сохраняет логи в файл, поддерживает создание и чтение логов из файла.
Logger - Центральный менеджер логирования.
-------------------------------------------------------------
Проект Ca_07_MultiLogService_02
-------------------------------------------------------------
В этом проекте мы переименовываем Logger в MultiLogger.
И при помощи шаблонной магии
Создаем MultiLogService, связывая MultiLogger и SingleThreadExecutor в Wrapper c именем MultiLogService
Было так:
LogService<ConsoleLogger, SingleThreadExecutor> log_sevice;
Стало вот так:
MultiLogService<MultiLogger, SingleThreadExecutor> multi_log_service;
--------------------------------------------------------------------------------------
Проект Ca_08_MultiLogServiceAdvanced_01
---------------------------------------------------------------------------------------
В этом проекте усиливаем Executor
Для этого разрабатываем компонент MultiSequentialExecutor.
И опять применям шаблонную магию получаем
Было так:
MultiLogService<MultiLogger, SingleThreadExecutor> multi_log_service;
Стало так:
MultiLogServiceAdvanced<MultiLogger, MultiSequentialExecutor> multi_log_service_adv(3);
MultiLogger c исполнением каждого Logger-а в отдельном потоке в контексте MultiSequentialExecutor.
------------------------------------------------------------------------------------
Проект Ca_09_MultiLog_SequentialExecution_01
------------------------------------------------------------------------------------
Реализация MultiLogger (Поведение) в однопоточном потоке (Исполнения) SingleExecutor
// Создаем SingleExecutor
SingleExecutor executor;
// Создаем MultiLogger, параметризованный SingleExecutor
MultiLogger<SingleExecutor> multiLogger(executor);

Программа представляет собой систему многоуровневого логирования с последовательным выполнением задач. Основные компоненты:

    DateTimeFormatter
        Форматирование времени в различных форматах (с датой и без)
        Поддержка микро- и миллисекунд
        Потокобезопасная реализация с использованием mutex
    MultiLogger
        Менеджер логгеров с поддержкой нескольких каналов
        Последовательное выполнение через SingleExecutor
        Управление несколькими логгерами одновременно
    Логгеры
        ConsoleLogger - вывод в консоль
        MemoryLogger - хранение в памяти (ограниченный размер)
        FileLogger - запись в файл
    SingleExecutor
        Последовательный исполнитель задач
        Использование C++20 std::jthread
        Безопасное завершение через std::stop_token
--------------------------------------------------------------------------------------
Проект Ca_10_MultiLog_MultiSequentialExecutor_02
--------------------------------------------------------------------------------------
Реализация MultiLogger (Поведение) в многопоточном потоке (Исполнения) MultiSequentialExecutor

// Создаем MultiSequentialExecutor с 3 SingleExecutor
MultiSequentialExecutor<SingleExecutor> executor(3);

// Создаем MultiLogger, используя MultiSequentialExecutor
MultiLogger<MultiSequentialExecutor<SingleExecutor>> multiLogger(executor);

Программа представляет собой систему многоуровневого логирования с параллельным выполнением задач. Основные компоненты:

    MultiSequentialExecutor
        Управляет несколькими SingleExecutor для параллельного выполнения задач
        Распределяет задачи между исполнителями по ID
        Обеспечивает последовательное выполнение в каждом потоке
    SingleExecutor
        Последовательный исполнитель задач в отдельном потоке
        Использует std::jthread и std::stop_token
        Потокобезопасная очередь задач
    MultiLogger
        Менеджер логгеров с поддержкой нескольких каналов
        Использует MultiSequentialExecutor для параллельного выполнения
        Автоматическое присвоение ID каналам
    Логгеры
        ConsoleLogger - вывод в консоль
        MemoryLogger - хранение в памяти
        FileLogger - запись в файл
    DateTimeFormatter
        Форматирование времени в различных форматах
        Потокобезопасная реализация
        Поддержка микро- и миллисекунд
--------------------------------------------------------------------------------------
Проект Ca_11_MultiLog_MultiSequentialExecutor_Wrapper_01
-------------------------------------------------------------------------------------
MultiLoggerMultiThreaded<MultiLogger<MultiSequentialExecutor<SingleExecutor>>, // MultiLogger
     MultiSequentialExecutor<SingleExecutor>> // MultiSequentialExecutor
     multiLogger_multiThreaded_service(3);

Если кто сразу не понял, это ОДНА строка кода. Шаблонная магия рулит.
Вот это совсем уже трэш. Сделан Wrapper MultiLoggerMultiThreaded.
Все компоненты понятны. Максимальная гибкость. Любую конструкцию можно обновлять отдельно от остальных.
Там описание в проекте есть в main().

Здесь представлена Эволюция программного кода Регистратора сообщений.
Мы начали с ConsoleLogger logger в проекте CA_01:
то есть c std::cout << "Hello World" << std::endl;

и закончили вот таким монстром в проекте CA_11:
MultiLoggerMultiThreaded<MultiLogger<MultiSequentialExecutor<SingleExecutor>>, // MultiLogger
     MultiSequentialExecutor<SingleExecutor>> // MultiSequentialExecutor
     multiLogger_multiThreaded_service(3);
Максимальная гибкость и взаимозаменямость всех компонентов.
--------------------------------------------------------------------------------------