----------------------------------------------------------------------
Проект Ca_05_Logger_Executor_In_Service_01
----------------------------------------------------------------------
Подробное описание программы
Программа представляет собой шаблонный контейнер LogService,
который объединяет два независимых модуля — класс логирования (Logger)
и исполнитель задач (Executor) в единую систему.
Это делается благодаря использованию шаблонов в стиле "обобщённого программирования".
Такой подход улучшает читаемость, упрощает сопровождение кода и позволяет гибко заменять
компоненты без переписывания основной логики.
Идея прекрасно демонстрирует концепцию разделения ответственности (Separation of Concerns),
где:
•	Логгер занимается формированием и обработкой текстовых сообщений в зависимости от уровня логирования
	 (например, INFO, WARNING, ERROR и т.д.).
•	Исполнитель управляет выполнением задач логирования в потокобезопасной инфраструктуре
	(в данном случае, благодаря однопоточному исполнителю задач, SingleThreadExecutor).
Затем эти две ответственности объединяются в едином шаблонном классе LogService.
Использование шаблонов делает структуру кода не только модульной, но и легко расширяемой.
Используя другие классы логгеров или исполнителей (например, FileLogger, MultiThreadExecutor),
можно быстро реорганизовать систему под новые задачи.
________________________________________
Основные компоненты программы
1.	Logger (ConsoleLogger): 
o	Это класс, который реализует функционал логирования.
o	Вывод осуществляется потокобезопасно и красиво отформатирован в консоль с указанием уровня лога
	(например, [INFO], [FATAL]) и времени.
o	Логгер автономен, не занимается конкурентным выполнением задач — только принимает их для обработки.
2.	Executor (SingleThreadExecutor): 
o	Этот класс отвечает за создание отдельного потока для выполнения задач.
o	Работает с потокобезопасной структурой (в данном случае, с очередью задач std::queue).
o	Обеспечивает асинхронность логирования, то есть задачи выполняются в отдельном потоке,
	не блокируя основной поток программы.
o	Используется std::jthread с корректной логикой остановки потока при завершении программы.
3.	LogService: 
o	Это шаблонный класс-обёртка, объединяющий Logger и Executor в единое целое.
o	Шаблонность позволяет свободно заменить как Logger (например, FileLogger вместо ConsoleLogger),
	так и Executor (например, MultiThreadExecutor вместо SingleThreadExecutor).
o	Подобная реализация чиста, универсальна и предоставляет интерфейс высокого уровня
	для конечного пользователя, т.е. можно просто вызывать log_service.Log(...).
4.	Основной поток программы (main()):
o	Создаётся объект LogService с конкретными реализациями логгера и исполнителя
	(ConsoleLogger и SingleThreadExecutor).
o	Логгер запускается, регистрирует события (например, сообщения об успехе,
	информационные или критические ошибки) и останавливается с выполнением всех оставшихся
	задач в очереди.
________________________________________
Плюсы архитектуры и шаблонной магии
1.	Разделение ответственности:
o	С развитием программы компоненты можно улучшать независимо друг от друга.
o	Например, можно заменить ConsoleLogger на другой класс лога (например, записывающий логи в файл),
	не касаясь логики исполнителя.
2.	Модульность и гибкость:
o	Благодаря LogService, конечный пользователь не думает о тонкостях реализации (например, о потокобезопасности),
	а напрямую вызывает Log через единый интерфейс.
3.	Шаблоны обеспечивают обобщённость:
o	Реализация через шаблоны позволяет повторно использовать LogService для любых других комбинаций логгеров и исполнителей.
4.	Асинхронная обработка задач:
o	Логирование не блокирует основной поток.
o	Сами задачи (логи) добавляются в очередь и обрабатываются в  Executer, делая приложение отзывчивым.
5.	Простота добавления новых возможностей:
o	Новый логгер или новый исполнитель легко встраиваются как отдельные модули.
________________________________________
Критика и код-ревью
1. ConsoleLogger - компонент
Плюсы:
•	Хорошее форматирование времени с использованием std::put_time.
•	Потокобезопасность вывода с использованием std::mutex.
•	Поддержка всех необходимых уровней логов (SUCCESS, WARNING, FATAL и т.п.).
Замечания:
•	Функция FormatLogLevel может приводить к небольшим затратам из-за явного копирования строк.
	Можно рассмотреть использование constexpr в сочетании с std::string_view.
•	В настоящих приложениях стоит сделать логгер более расширяемым (например, добавить возможность указания пользовательского формата времени).
Пример оптимизации метода FormatLogLevel:
std::string_view ConsoleLogger::FormatLogLevel(LogLevel level) {
    switch (level) {
        case LogLevel::SUCCESS: return "[SUCCESS]";
        case LogLevel::WARNING: return "[WARNING]";
        case LogLevel::FATAL:   return "[FATAL]";
        // ... другие уровни
        default:                return "[UNKNOWN]";
    }
}
________________________________________
2. SingleThreadExecutor - компонент
Плюсы:
•	Грамотная потокобезопасная очередь с использованием std::mutex и std::condition_variable.
•	Логика остановки потока (Stop) реализована корректно с пробуждением waiting-потока.
•	Реализация делает код безопасным в многопоточном окружении.
Замечания:
•	Поток (std::jthread) создаётся только после вызова Start, что экономит ресурсы.
•	Неблокирующий выход из WorkerLoop — отличный стиль!
Рекомендация:
•	Добавить таймаут в cv_.wait на случай блокировок (например, при нештатных ситуациях).
Пример:
cv_.wait_for(lock, std::chrono::seconds(1), [&] { return !logQueue_.empty() || !running_; });
________________________________________
3. LogService
Плюсы:
•	Шаблонность универсальна. Можно легко заменять компоненты.
•	Управление жизненным циклом (Start/Stop) хорошо продумано.
Замечания:
•	Логика Stop дублирует вызов в деструкторе и функции Stop() (можно упростить).
•	В текущей реализации logger_ и executor_ — это std::unique_ptr.
	Однако реализация требует лишних аллокаций в куче. Использовать std::optional (или стандартные объекты):
LoggerType logger_;
ExecutorType executor_;
________________________________________
Заключение
Код программы демонстрирует высокоуровневый, модульный, гибкий дизайн, что очень ценно для масштабируемых систем.
Реализация корректная, соответствует современным стандартам C++.
Для дальнейшего улучшения кода можно добавить:
1.	Возможность выбрать, куда писать логи (например, FileLogger).
2.	Поддержку нескольких потоков в Executor для улучшения производительности в высоконагруженных системах.
3.	Добавление тестов для проверки потокобезопасности логирования.
В текущем виде программа демонстрирует концепцию "Чистого Кода" и принцип SOLID,
что делает её удобной для дальнейшего развития.
